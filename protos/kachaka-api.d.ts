/* this code was generated by automated tool, 
   should not edit by hand */

export interface KachakaApi {
  GetRobotSerialNumber(request: GetRequest): Promise<GetRobotSerialNumberResponse>;
  GetRobotVersion(request: GetRequest): Promise<GetRobotVersionResponse>;
  GetRobotPose(request: GetRequest): Promise<GetRobotPoseResponse>;
  GetPngMap(request: GetRequest): Promise<GetPngMapResponse>;
  GetObjectDetection(request: GetRequest): Promise<GetObjectDetectionResponse>;
  GetRosImu(request: GetRequest): Promise<GetRosImuResponse>;
  GetRosOdometry(request: GetRequest): Promise<GetRosOdometryResponse>;
  GetRosLaserScan(request: GetRequest): Promise<GetRosLaserScanResponse>;
  GetFrontCameraRosCameraInfo(request: GetRequest): Promise<GetFrontCameraRosCameraInfoResponse>;
  GetFrontCameraRosImage(request: GetRequest): Promise<GetFrontCameraRosImageResponse>;
  GetFrontCameraRosCompressedImage(request: GetRequest): Promise<GetFrontCameraRosCompressedImageResponse>;
  StartCommand(request: StartCommandRequest): Promise<StartCommandResponse>;
  // CancelCommand(request: EmptyRequest): Promise<CancelCommandResponse>;
  GetCommandState(request: GetRequest): Promise<GetCommandStateResponse>;
  GetLastCommandResult(request: GetRequest): Promise<GetLastCommandResultResponse>;
  GetLocations(request: GetRequest): Promise<GetLocationsResponse>;
  GetShelves(request: GetRequest): Promise<GetShelvesResponse>;
  SetAutoHomingEnabled(request: SetAutoHomingEnabledRequest): Promise<SetAutoHomingEnabledResponse>;
  GetAutoHomingEnabled(request: GetRequest): Promise<GetAutoHomingEnabledResponse>;
  SetManualControlEnabled(request: SetManualControlEnabledRequest): Promise<SetManualControlEnabledResponse>;
  GetManualControlEnabled(request: GetRequest): Promise<GetManualControlEnabledResponse>;
  SetRobotVelocity(request: SetRobotVelocityRequest): Promise<SetRobotVelocityResponse>;
  GetHistoryList(request: GetRequest): Promise<GetHistoryListResponse>;
  // GetStaticTransform(request: GetRequest): Promise<GetStaticTransformResponse>;
  // GetDynamicTransform(request: EmptyRequest): AsyncGenerator<GetDynamicTransformResponse>;
}

export interface Metadata {
  cursor?: number;
}

export interface Result {
  success?: boolean;
  errorCode?: number;
}

export interface Error {
  errorCode?: number;
}

export interface RosHeader {
  stampNsec?: number;
  frameId?: string;
}

export interface Pose {
  x?: number;
  y?: number;
  theta?: number;
}

export interface Vector3 {
  x?: number;
  y?: number;
  z?: number;
}

export interface Quaternion {
  x?: number;
  y?: number;
  z?: number;
  w?: number;
}

export interface Pose3d {
  position?: Vector3;
  orientation?: Quaternion;
}

export interface Twist {
  linear?: Vector3;
  angular?: Vector3;
}

export interface Pose3dWithCovariance {
  pose?: Pose3d;
  covariance?: number[];
}

export interface TwistWithCovariance {
  twist?: Twist;
  covariance?: number[];
}

export interface Map {
  data?: Uint8Array;
  name?: string;
  resolution?: number;
  width?: number;
  height?: number;
  origin?: Pose;
}

export type LocationType = "LOCATION_TYPE_UNSPECIFIED" | "LOCATION_TYPE_CHARGER" | "LOCATION_TYPE_SHELF_HOME" | string;

export interface Location {
  id?: string;
  name?: string;
  pose?: Pose;
  type?: LocationType;
  undockShelfAligningToWall?: boolean;
  undockShelfAvoidingObstacles?: boolean;
  ignoreVoiceRecognition?: boolean;
}

export interface ShelfSize {
  width?: number;
  depth?: number;
  height?: number;
}

export type ShelfAppearance = "SHELF_APPEARANCE_UNSPECIFIED" | "SHELF_APPEARANCE_DEFAULT_SHELF" | "SHELF_APPEARANCE_KACHAKA_SHELF_3DRAWERS" | "SHELF_APPEARANCE_KACHAKA_SHELF_2DRAWERS" | string;

export type ShelfSpeedMode = "SHELF_SPEED_MODE_UNSPECIFIED" | "SHELF_SPEED_MODE_LOW" | "SHELF_SPEED_MODE_NORMAL" | string;

export interface RecognizableName {
  name?: string;
  deletable?: boolean;
}

export interface Shelf {
  id?: string;
  name?: string;
  pose?: Pose;
  size?: ShelfSize;
  appearance?: ShelfAppearance;
  recognizableNames?: RecognizableName[];
  homeLocationId?: string;
  speedMode?: ShelfSpeedMode;
  ignoreVoiceRecognition?: boolean;
}

export interface RosImu {
  header?: RosHeader;
  orientation?: Quaternion;
  orientationCovariance?: number[];
  angularVelocity?: Vector3;
  angularVelocityCovariance?: number[];
  linearAcceleration?: Vector3;
  linearAccelerationCovariance?: number[];
}

export interface RosOdometry {
  header?: RosHeader;
  childFrameId?: string;
  pose?: Pose3dWithCovariance;
  twist?: TwistWithCovariance;
}

export interface RosLaserScan {
  header?: RosHeader;
  angleMin?: number;
  angleMax?: number;
  angleIncrement?: number;
  timeIncrement?: number;
  scanTime?: number;
  rangeMin?: number;
  rangeMax?: number;
  ranges?: number[];
  intensities?: number[];
}

export interface RegionOfInterest {
  xOffset?: number;
  yOffset?: number;
  height?: number;
  width?: number;
  doRectify?: boolean;
}

export interface RosCameraInfo {
  header?: RosHeader;
  height?: number;
  width?: number;
  distortionModel?: string;
  D?: number[];
  K?: number[];
  R?: number[];
  P?: number[];
  binningX?: number;
  binningY?: number;
  roi?: RegionOfInterest;
}

export interface RosImage {
  header?: RosHeader;
  height?: number;
  width?: number;
  encoding?: string;
  isBigendian?: boolean;
  step?: number;
  data?: Uint8Array;
}

export interface RosTransformStamped {
  header?: RosHeader;
  childFrameId?: string;
  translation?: Vector3;
  rotation?: Quaternion;
}

export interface RosCompressedImage {
  header?: RosHeader;
  format?: string;
  data?: Uint8Array;
}

export type ObjectLabel = "OBJECT_LABEL_UNSPECIFIED" | "OBJECT_LABEL_PERSON" | "OBJECT_LABEL_SHELF" | "OBJECT_LABEL_CHARGER" | "OBJECT_LABEL_DOOR" | string;

export interface ObjectDetection {
  label?: number;
  roi?: RegionOfInterest;
  score?: number;
  distanceMedian?: number;
}

export interface Command {
  moveShelfCommand?: MoveShelfCommand;
  returnShelfCommand?: ReturnShelfCommand;
  undockShelfCommand?: UndockShelfCommand;
  moveToLocationCommand?: MoveToLocationCommand;
  returnHomeCommand?: ReturnHomeCommand;
  dockShelfCommand?: DockShelfCommand;
  speakCommand?: SpeakCommand;
  moveToPoseCommand?: MoveToPoseCommand;
}

export interface MoveShelfCommand {
  targetShelfId?: string;
  destinationLocationId?: string;
}

export interface ReturnShelfCommand {
  targetShelfId?: string;
}

export interface UndockShelfCommand {
  targetShelfId?: string;
}

export interface MoveToLocationCommand {
  targetLocationId?: string;
}

export interface ReturnHomeCommand {

}

export interface DockShelfCommand {

}

export interface SpeakCommand {
  text?: string;
}

export interface MoveToPoseCommand {
  x?: number;
  y?: number;
  yaw?: number;
}

export enum CommandState {
  COMMAND_STATE_UNSPECIFIED = 0,
  COMMAND_STATE_PENDING = 1,
  COMMAND_STATE_RUNNING = 2,
}

export interface EmptyRequest {

}

export interface GetRequest {
  metadata?: Metadata;
}

export interface GetRobotSerialNumberResponse {
  metadata?: Metadata;
  serialNumber?: string;
}

export interface GetRobotVersionResponse {
  metadata?: Metadata;
  version?: string;
}

export interface GetRobotPoseResponse {
  metadata?: Metadata;
  pose?: Pose;
}

export interface GetPngMapResponse {
  metadata?: Metadata;
  map?: Map;
}

export interface GetObjectDetectionResponse {
  metadata?: Metadata;
  header?: RosHeader;
  objects?: ObjectDetection[];
}

export interface GetRosImuResponse {
  metadata?: Metadata;
  imu?: RosImu;
}

export interface GetRosOdometryResponse {
  metadata?: Metadata;
  odometry?: RosOdometry;
}

export interface GetRosLaserScanResponse {
  metadata?: Metadata;
  scan?: RosLaserScan;
}

export interface GetFrontCameraRosCameraInfoResponse {
  metadata?: Metadata;
  cameraInfo?: RosCameraInfo;
}

export interface GetFrontCameraRosImageResponse {
  metadata?: Metadata;
  image?: RosImage;
}

export interface GetFrontCameraRosCompressedImageResponse {
  metadata?: Metadata;
  image?: RosCompressedImage;
}

export interface StartCommandRequest {
  command?: Command;
  cancelAll?: boolean;
  ttsOnSuccess?: string;
  title?: string;
}

export interface StartCommandResponse {
  result?: Result;
  commandId?: string;
}

export interface CancelCommandResponse {
  result?: Result;
  command?: Command;
}

export interface GetCommandStateResponse {
  metadata?: Metadata;
  state?: CommandState;
  command?: Command;
}

export interface GetLastCommandResultResponse {
  metadata?: Metadata;
  result?: Result;
  command?: Command;
}

export interface GetLocationsResponse {
  metadata?: Metadata;
  locations?: Location[];
  defaultLocationId?: string;
}

export interface GetShelvesResponse {
  metadata?: Metadata;
  shelves?: Shelf[];
}

export interface SetAutoHomingEnabledRequest {
  enable?: boolean;
}

export interface SetAutoHomingEnabledResponse {
  result?: Result;
}

export interface GetAutoHomingEnabledResponse {
  metadata?: Metadata;
  enabled?: boolean;
}

export interface SetManualControlEnabledRequest {
  enable?: boolean;
  useShelfRegistration?: boolean;
}

export interface SetManualControlEnabledResponse {
  result?: Result;
}

export interface GetManualControlEnabledResponse {
  metadata?: Metadata;
  enabled?: boolean;
}

export interface SetRobotVelocityRequest {
  linear?: number;
  angular?: number;
}

export interface SetRobotVelocityResponse {
  result?: Result;
}

export interface GetStaticTransformResponse {
  metadata?: Metadata;
  transforms?: RosTransformStamped[];
}

export interface GetDynamicTransformResponse {
  transforms?: RosTransformStamped[];
}

export interface History {
  id?: string;
  command?: Command;
  success?: boolean;
  errorCode?: number;
  commandExecutedTime?: number;
}

export interface GetHistoryListResponse {
  metadata?: Metadata;
  histories?: History[];
}
